import os
import numpy as np
import pandas as pd

# --- Global Configuration ---
BASE_DIR = r'D:\python-files\wuhan\high-order network in city'
CACHE_DIR = os.path.join(BASE_DIR, 'cache')
os.makedirs(CACHE_DIR, exist_ok=True)

NUM_STEPS = 4
ATTACK_SCENARIOS = ['rnd', 'nd', 'bc']

# --- Core Synchronization: This number must exactly match NUM_BENCHMARKS used in code5! ---
# We use 50 here to match the number of repetitions for random attacks in code6, ensuring statistical robustness.
NUM_BENCHMARK_TESTS = 50

CACHE_FILE = os.path.join(CACHE_DIR, 'zscore_analysis_data.csv')


def calculate_rb_from_file(filepath):
    """Loads data from a CSV file and calculates the Rb value (using trapz to avoid warnings)"""
    try:
        df = pd.read_csv(filepath, header=None, names=['S', 'q', 'std'])
        if df.empty or len(df) < 2: return 0.0
        # Ensure data is sorted by q values for correct area calculation
        df_sorted = df.sort_values('q')
        return np.trapz(y=df_sorted['S'], x=df_sorted['q'])
    except (pd.errors.EmptyDataError, ValueError, FileNotFoundError):
        return None


if __name__ == '__main__':
    print("--- Part 1: Calculating Z-Scores and Caching Data (v2.0) ---")
    results_list = []

    for imt_distance in [0, 100]:
        print(f"\n> Processing IMT Distance: {imt_distance}m")
        for scenario in ATTACK_SCENARIOS:
            for step in range(NUM_STEPS):
                step_index = step + 1

                # 1. Load real network resilience data (generated by code6_v2)
                system_file = os.path.join(CACHE_DIR,
                                           f"evolution_imt_{imt_distance}_step_{step_index}_attack_{scenario}.csv")
                system_rb = calculate_rb_from_file(system_file)
                if system_rb is None:
                    print(
                        f"  [Warning] Skipping: Real network data not found for step {step_index}, imt {imt_distance}, scenario {scenario}.")
                    continue

                # 2. Load resilience data for all benchmark models (generated by code5_v2)
                benchmark_rbs = [
                    calculate_rb_from_file(os.path.join(CACHE_DIR,
                                                        f"benchmark_imt_{imt_distance}_step_{step_index}_attack_{scenario}_run_{test}.csv"))
                    for test in range(NUM_BENCHMARK_TESTS)
                ]
                benchmark_rbs = [rb for rb in benchmark_rbs if rb is not None]

                if not benchmark_rbs:
                    print(
                        f"  [Warning] Skipping: No benchmark data found for step {step_index}, imt {imt_distance}, scenario {scenario}.")
                    continue

                if len(benchmark_rbs) < NUM_BENCHMARK_TESTS:
                    print(
                        f"  [Info] Found {len(benchmark_rbs)}/{NUM_BENCHMARK_TESTS} benchmark files for step {step_index}, imt {imt_distance}, scenario {scenario}.")

                # 3. Calculate Z-Score
                benchmark_mean = np.mean(benchmark_rbs)
                benchmark_std = np.std(benchmark_rbs)
                z_score = (system_rb - benchmark_mean) / benchmark_std if benchmark_std > 1e-9 else 0.0

                results_list.append({
                    'IMT_Distance': imt_distance,
                    'Attack_Scenario': scenario.upper(),
                    'Step': step_index,
                    'Z_Score': z_score
                })
                print(
                    f"  - Calculated Z-Score for Step {step_index}, IMT {imt_distance}, Attack {scenario.upper()}: {z_score:.4f}")

    if results_list:
        df_results = pd.DataFrame(results_list)
        df_results.to_csv(CACHE_FILE, index=False)
        print(f"\n--- Z-Score data successfully calculated and saved to: {CACHE_FILE} ---")
    else:
        print(
            "\n--- No data generated. Please check if the prerequisite scripts (code5, code6) have been run successfully. ---")
